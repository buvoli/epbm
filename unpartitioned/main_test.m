%% == Equation======================================================================================================= %%
ADR = PLN_ADR2d();
num_timesteps = 100;
error_norm = @(x,y) norm((x(:) - y(:))./(x(:) + eps), Inf);
stiff_type = 'NL'; % 'L' - stiff linear terms, 'NL' - stiff nonlinear terms

switch stiff_type
    case 'L'
        ADR.tspan          = [0, 0.01];
        ADR.params.epsilon = 1 / 100;
        ADR.params.alpha   = -10;
        ADR.params.gamma   = 100;
    case 'NL'
        ADR.tspan          = [0, 0.01];
        ADR.params.epsilon = 1 / 10000;
        ADR.params.alpha   = -1 / 10;
        ADR.params.gamma   = 1000;
end

%% == KIOPS ========================================================================================================= %%
phi_evaluator = @KIOPS;
phi_options = struct(                  ...
    'max_iterations',   100,           ...
    'tolerance',        1e-12,         ...
    'record_stats',     true,          ...
    'min_tau', 1e-3                    ...
);

%% == EPBM Integrators ============================================================================================== %%
order = 6; 
epiLegPBM = epiLegPBMConst( ...
        struct( ...
            'q', order, ...
            'm', 0, ...
            'alpha', 2, ...
            'phi_evaluator', phi_evaluator(phi_options), ...
            'record_stats', true ...
        ) ...
    );

epiLegPBM.num_timesteps = num_timesteps;
y_out_pbm = epiLegPBM.solve(ADR);
fprintf('EPBM Error: %e\n', error_norm(y_out_pbm, ADR.reference_solution)) % note: first call to ADR.reference_solution computes reference solution and takes longer
fprintf('EPBM Time: %f\n',  epiLegPBM.step_stats.total_seconds)

%% == EAB Integrators =============================================================================================== %%
order = 6;
epiAB = epiABConst( ...
        struct( ...
            'order', order, ...
            'phi_evaluator', phi_evaluator(phi_options), ...
            'record_stats', true, ...
            'step_backwards_for_ic', true ...
        ) ...
    );
epiAB.starting_integrator_timeout = 60; % going backwards in time can cause initial condition code to hang
epiAB.num_timesteps = num_timesteps;
y_out_ab = epiAB.solve(ADR);
fprintf('EAB Error: %e\n', error_norm(y_out_ab, ADR.reference_solution))
fprintf('EAB Time: %f\n',  epiAB.step_stats.total_seconds)

%% == EPIRK Integrators ============================================================================================= %%
epirk43s = epirk4s3Const( ...
    struct(  ...
    'phi_evaluator', phi_evaluator(phi_options), ...
    'record_stats', true ...
    ));

epirk43s.num_timesteps = num_timesteps;
y_out_rk = epirk43s.solve(ADR);
fprintf('ERK Error: %e\n', error_norm(y_out_rk, ADR.reference_solution))
fprintf('ERK Time: %f\n',  epirk43s.step_stats.total_seconds)

%% == ESDC Integrators ============================================================================================== %%
order  = 6;
sweeps = @(p) p - 1;
nodes  = @(p) (chebpts(p) + 1) / 2;

episdc = epiSDCConst( ...
        struct( ...
            'nodes', nodes(order), ...
            'sweeps', sweeps(order), ...
            'phi_evaluator', phi_evaluator(phi_options), ...
            'record_stats', true ...
        ) ...
    );

episdc.num_timesteps = num_timesteps;
y_out_sdc = episdc.solve(ADR);
fprintf('ESDC Error: %e\n', error_norm(y_out_sdc, ADR.reference_solution))
fprintf('ESDC Time: %f\n',  episdc.step_stats.total_seconds)
